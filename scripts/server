#!/bin/bash

# Blog Local Server Management Script
# Manages blog backend, database, and related operations

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
BLOG_PORT=22222
DB_PORT=5433
LOG_DIR="./logs"
PID_DIR="./pids"
DOCKER_CONTAINER_NAME="pg"
DB_VOLUME_NAME="postgres-volume"

# Create directories if they don't exist
mkdir -p "$LOG_DIR" "$PID_DIR"

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_header() {
    echo -e "${BLUE}=== $1 ===${NC}"
}

# Function to show help
show_help() {
    echo -e "${CYAN}Blog Server Management Script${NC}"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo -e "${YELLOW}Server Commands:${NC}"
    echo "  start [--force]        Start all services (blog app, database)"
    echo "  stop                   Stop all services"
    echo "  restart [--force]      Restart all services"
    echo "  status                 Show status of all services"
    echo ""
    echo -e "${YELLOW}Individual Service Commands:${NC}"
    echo "  start-blog [--force]   Start blog application only"
    echo "  start-db [--force]     Start PostgreSQL database only"
    echo "  stop-blog              Stop blog application"
    echo "  stop-db                Stop PostgreSQL database"
    echo ""
    echo -e "${YELLOW}Development Commands:${NC}"
    echo "  dev [--force]          Start in development mode with air"
    echo "  build                  Build the blog application"
    echo "  docker-build           Build Docker image"
    echo "  docker-run             Run in Docker container"
    echo ""
    echo -e "${YELLOW}Log Commands:${NC}"
    echo "  logs [service]         Show logs for all services or specific service"
    echo "                         Services: blog, db, docker, all (default)"
    echo "  tail [service] [n]     Tail logs (default: 50 lines)"
    echo ""
    echo -e "${YELLOW}Database Commands:${NC}"
    echo "  db [query]             Execute SQL query on database"
    echo "  db-migrate             Run database migrations"
    echo "  db-reset               Reset database (drop and recreate)"
    echo "  db-seed                Load test data into database"
    echo "  db-users               Show all users"
    echo "  db-posts               Show all posts"
    echo "  db-roles               Show all roles"
    echo "  db-categories          Show all categories"
    echo ""
    echo -e "${YELLOW}API Commands:${NC}"
    echo "  add-user <email> <username> <password> [role_id]   Add new user"
    echo "  add-post <title> <content> [user_id] [category_id] Add new post"
    echo "  toggle-signup          Enable/disable user signups"
    echo "  api-test               Test API endpoints"
    echo ""
    echo -e "${YELLOW}Utility Commands:${NC}"
    echo "  health                 Check health of all services"
    echo "  clean                  Clean logs and temporary files"
    echo "  ports                  Show which ports are in use"
    echo "  env                    Show environment variables"
    echo ""
    echo -e "${YELLOW}Test Commands:${NC}"
    echo "  test-go                Run Go unit tests in tests/go"
    echo "  test-playwright        Run Playwright tests in tests/playwright"
    echo "  test-all               Run Go + Playwright tests"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  $0 start --force                                    # Force start all services"
    echo "  $0 dev --force                                      # Start in dev mode"
    echo "  $0 add-user user@example.com john password123 2     # Add user with role 2"
    echo "  $0 add-post \"My Post\" \"Content here\" 1 1         # Add post by user 1"
    echo "  $0 db \"SELECT * FROM users LIMIT 5;\"             # Execute SQL query"
    echo "  $0 logs blog                                        # Show blog logs"
    echo "  $0 tail db 100                                      # Tail database logs"
}

# Function to load environment variables
load_env() {
    if [ -f ".env" ]; then
        export $(cat .env | grep -v '^#' | xargs)
    else
        print_error ".env file not found"
        return 1
    fi
}

# Function to check if a port is in use
port_in_use() {
    lsof -i :$1 >/dev/null 2>&1
}

# Function to get PID using a port
get_pid_by_port() {
    lsof -ti :$1 2>/dev/null || echo ""
}

# Function to kill process by port
kill_by_port() {
    local port=$1
    local service=$2
    local pid=$(get_pid_by_port $port)
    
    if [ -n "$pid" ]; then
        print_status "Stopping $service (PID: $pid) on port $port..."
        kill $pid 2>/dev/null || true
        sleep 2
        
        # Force kill if still running
        if kill -0 $pid 2>/dev/null; then
            print_warning "Force killing $service..."
            kill -9 $pid 2>/dev/null || true
        fi
        print_success "$service stopped"
    else
        print_warning "$service not running on port $port"
    fi
}

# Function to start PostgreSQL database
start_db() {
    local force=false
    if [ "$1" = "--force" ]; then
        force=true
    fi
    
    print_header "Starting PostgreSQL Database"
    
    # Check if Docker container exists
    if docker ps -a --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
            if [ "$force" = true ]; then
                print_warning "Force stopping existing database container..."
                docker stop $DOCKER_CONTAINER_NAME
                sleep 2
            else
                print_warning "Database already running (use --force to restart)"
                return
            fi
        else
            print_status "Starting existing container..."
            docker start $DOCKER_CONTAINER_NAME
        fi
    else
        load_env
        print_status "Creating new PostgreSQL container..."
        
        # Create volume if it doesn't exist
        if ! docker volume ls | grep -q $DB_VOLUME_NAME; then
            docker volume create $DB_VOLUME_NAME
        fi
        
        docker run --name $DOCKER_CONTAINER_NAME \
            -e POSTGRES_PASSWORD=$PG_PASSWORD \
            -e POSTGRES_USER=$PG_USER \
            -p $PG_PORT:5432 \
            -v $DB_VOLUME_NAME:/var/lib/postgresql/data \
            -d postgres > "$LOG_DIR/docker.log" 2>&1
    fi
    
    # Wait for startup
    sleep 5
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_success "Database started on port $PG_PORT"
    else
        print_error "Database failed to start"
        print_status "Check logs with: $0 logs db"
    fi
}

# Function to start blog application
start_blog() {
    local force=false
    if [ "$1" = "--force" ]; then
        force=true
    fi
    
    print_header "Starting Blog Application"
    
    if port_in_use $BLOG_PORT; then
        if [ "$force" = true ]; then
            print_warning "Force stopping existing blog application..."
            kill_by_port $BLOG_PORT "Blog Application"
            sleep 2
        else
            print_warning "Blog already running on port $BLOG_PORT (use --force to restart)"
            return
        fi
    fi
    
    load_env
    
    # Build application if binary doesn't exist
    if [ ! -f "tmp/blog" ]; then
        print_status "Building application..."
        go build -o tmp/blog
    fi
    
    print_status "Starting blog application on port $BLOG_PORT..."
    nohup ./tmp/blog --listen-addr :$BLOG_PORT > "$LOG_DIR/blog.log" 2>&1 &
    echo $! > "$PID_DIR/blog.pid"
    
    # Wait for startup
    sleep 3
    if port_in_use $BLOG_PORT; then
        print_success "Blog application started at http://localhost:$BLOG_PORT"
    else
        print_error "Blog application failed to start"
        print_status "Check logs with: $0 logs blog"
    fi
}

# Function to start in development mode with air
start_dev() {
    local force=false
    if [ "$1" = "--force" ]; then
        force=true
    fi
    
    print_header "Starting Blog in Development Mode"
    
    if port_in_use $BLOG_PORT; then
        if [ "$force" = true ]; then
            print_warning "Force stopping existing blog application..."
            kill_by_port $BLOG_PORT "Blog Application"
            sleep 2
        else
            print_warning "Blog already running on port $BLOG_PORT (use --force to restart)"
            return
        fi
    fi
    
    load_env
    
    # Check if air is installed
    if ! command -v air >/dev/null 2>&1; then
        if ! command -v ~/go/bin/air >/dev/null 2>&1; then
            print_error "Air not found. Installing..."
            curl -sSfL https://raw.githubusercontent.com/cosmtrek/air/master/install.sh | sh -s -- -b $(go env GOPATH)/bin
        fi
    fi
    
    print_status "Starting blog with air (live reloading) on port $BLOG_PORT..."
    nohup ~/go/bin/air -c .air.toml > "$LOG_DIR/blog-dev.log" 2>&1 &
    echo $! > "$PID_DIR/blog-dev.pid"
    
    # Wait for startup
    sleep 5
    if port_in_use $BLOG_PORT; then
        print_success "Blog development server started at http://localhost:$BLOG_PORT"
        print_status "Live reloading enabled - changes will trigger rebuilds"
    else
        print_error "Blog development server failed to start"
        print_status "Check logs with: $0 logs blog"
    fi
}

# Function to restart only the blog app and rebuild binary (ensures embedded templates refresh)
restart_blog() {
    print_header "Rebuilding and Restarting Blog Application"
    # Stop if running
    if port_in_use $BLOG_PORT; then
        kill_by_port $BLOG_PORT "Blog Application"
        sleep 1
    fi
    # Rebuild fresh binary
    print_status "Rebuilding application binary..."
    rm -f tmp/blog || true
    go build -o tmp/blog
    # Start
    start_blog --force
}

# Function to stop services
stop_blog() {
    print_header "Stopping Blog Application"
    kill_by_port $BLOG_PORT "Blog Application"
    rm -f "$PID_DIR/blog.pid" "$PID_DIR/blog-dev.pid"
}

stop_db() {
    print_header "Stopping PostgreSQL Database"
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        docker stop $DOCKER_CONTAINER_NAME
        print_success "Database stopped"
    else
        print_warning "Database not running"
    fi
}

# Function to show service status
show_status() {
    print_header "Service Status"
    
    echo -e "${CYAN}Blog Application:${NC}"
    if port_in_use $BLOG_PORT; then
        echo -e "  ${GREEN}✓ Running${NC} on port $BLOG_PORT (http://localhost:$BLOG_PORT)"
    else
        echo -e "  ${RED}✗ Not running${NC}"
    fi
    
    echo -e "${CYAN}PostgreSQL Database:${NC}"
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        load_env
        echo -e "  ${GREEN}✓ Running${NC} on port $PG_PORT (Container: $DOCKER_CONTAINER_NAME)"
    else
        echo -e "  ${RED}✗ Not running${NC}"
    fi
}

# Function to show logs
show_logs() {
    local service=${1:-all}
    local lines=${2:-50}
    
    case $service in
        blog)
            if [ -f "$LOG_DIR/blog.log" ]; then
                print_header "Blog Application Logs (last $lines lines)"
                tail -n $lines "$LOG_DIR/blog.log"
            elif [ -f "$LOG_DIR/blog-dev.log" ]; then
                print_header "Blog Development Logs (last $lines lines)"
                tail -n $lines "$LOG_DIR/blog-dev.log"
            else
                print_warning "Blog logs not found"
            fi
            ;;
        db|docker)
            if [ -f "$LOG_DIR/docker.log" ]; then
                print_header "Database Logs (last $lines lines)"
                tail -n $lines "$LOG_DIR/docker.log"
            else
                print_warning "Database logs not found"
            fi
            # Also show Docker container logs
            if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
                print_header "PostgreSQL Container Logs (last $lines lines)"
                docker logs --tail $lines $DOCKER_CONTAINER_NAME
            fi
            ;;
        all|*)
            print_header "All Service Logs (last $lines lines each)"
            show_logs blog $lines
            echo ""
            show_logs db $lines
            ;;
    esac
}

# Function to tail logs
tail_logs() {
    local service=${1:-blog}
    local lines=${2:-50}
    
    case $service in
        blog)
            if [ -f "$LOG_DIR/blog.log" ]; then
                print_header "Tailing Blog Application Logs"
                tail -f -n $lines "$LOG_DIR/blog.log"
            elif [ -f "$LOG_DIR/blog-dev.log" ]; then
                print_header "Tailing Blog Development Logs"
                tail -f -n $lines "$LOG_DIR/blog-dev.log"
            else
                print_warning "Blog logs not found"
            fi
            ;;
        db|docker)
            print_header "Tailing Database Container Logs"
            if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
                docker logs -f --tail $lines $DOCKER_CONTAINER_NAME
            else
                print_warning "Database container not running"
            fi
            ;;
        *)
            print_error "Cannot tail logs for service: $service. Choose: blog, db"
            ;;
    esac
}

# Database functions
execute_db_query() {
    local query="$1"
    
    load_env
    
    print_header "Database Query"
    echo -e "${CYAN}Query:${NC} $query"
    echo ""
    
    if ! docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_error "Database not running. Start with: $0 start-db"
        return 1
    fi
    
    docker exec $DOCKER_CONTAINER_NAME psql -U $PG_USER -d $PG_DB -c "$query"
}

run_migrations() {
    print_header "Running Database Migrations"
    
    load_env
    
    if ! command -v migrate >/dev/null 2>&1; then
        print_error "golang-migrate not installed. Install with: brew install golang-migrate"
        return 1
    fi
    
    if ! docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_error "Database not running. Start with: $0 start-db"
        return 1
    fi
    
    migrate -source file://migrations -database "postgresql://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DB?sslmode=disable" up
    print_success "Migrations completed"
}

reset_database() {
    print_header "Resetting Database"
    
    echo -e "${RED}WARNING: This will delete all data!${NC}"
    read -p "Are you sure? Type 'yes' to confirm: " confirm
    
    if [ "$confirm" != "yes" ]; then
        print_status "Operation cancelled"
        return
    fi
    
    load_env
    
    # Stop database
    stop_db
    
    # Remove volume
    if docker volume ls | grep -q $DB_VOLUME_NAME; then
        print_status "Removing database volume..."
        docker volume rm $DB_VOLUME_NAME
    fi
    
    # Remove container
    if docker ps -a --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_status "Removing database container..."
        docker rm $DOCKER_CONTAINER_NAME
    fi
    
    # Start fresh
    start_db
    sleep 5
    run_migrations
    print_success "Database reset completed"
}

seed_database() {
    print_header "Seeding Database with Test Data"
    
    if [ -f "db_test.sh" ]; then
        print_status "Running test data script..."
        # Modify db_test.sh to work with our setup
        load_env
        
        # Insert roles
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Commenter') ON CONFLICT DO NOTHING;"
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Administrator') ON CONFLICT DO NOTHING;"
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Editor') ON CONFLICT DO NOTHING;"
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Viewer') ON CONFLICT DO NOTHING;"
        
        # Insert category
        execute_db_query "INSERT INTO CATEGORIES (category_name) VALUES ('Demo Category') ON CONFLICT DO NOTHING;"
        
        # Add users via API if blog is running
        if port_in_use $BLOG_PORT; then
            print_status "Adding test users via API..."
            add_user "anshuman@biswas.me" "anshuman" "123456qwertyu" 1
            add_user "anchoo2kewl@gmail.com" "anchoo2kewl" "123456qwertyu" 2
            
            print_status "Adding test posts via API..."
            add_post "Fictitious Blog Post" "Lorem ipsum dolor sit amet, consectetur adipiscing elit..." 2 1
            add_post "Exploring the Cosmos" "Curabitur dictum malesuada massa, eu tempor leo sagittis nec..." 2 1
        else
            print_warning "Blog not running. Start blog first to add users/posts via API"
        fi
        
        print_success "Database seeded with test data"
    else
        print_warning "db_test.sh not found"
    fi
}

# API functions
add_user() {
    local email="$1"
    local username="$2"
    local password="$3"
    local role_id="${4:-1}"
    
    if [ -z "$email" ] || [ -z "$username" ] || [ -z "$password" ]; then
        print_error "Usage: add_user <email> <username> <password> [role_id]"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    print_status "Adding user: $username ($email)"
    
    curl -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_TOKEN" \
        -d "{\"email\":\"$email\",\"username\":\"$username\",\"password\":\"$password\",\"role\":$role_id}" \
        "http://localhost:$BLOG_PORT/api/users" | jq '.' || echo ""
}

add_post() {
    local title="$1"
    local content="$2"
    local user_id="${3:-2}"
    local category_id="${4:-1}"
    
    if [ -z "$title" ] || [ -z "$content" ]; then
        print_error "Usage: add_post <title> <content> [user_id] [category_id]"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    # Generate slug from title
    local slug=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
    
    print_status "Adding post: $title"
    
    curl -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_TOKEN" \
        -d "{\"userID\":$user_id,\"categoryID\":$category_id,\"title\":\"$title\",\"slug\":\"$slug\",\"content\":\"$content\",\"isPublished\":true}" \
        "http://localhost:$BLOG_PORT/api/posts" | jq '.' || echo ""
}

toggle_signup() {
    load_env
    
    print_header "Toggle User Signups"
    
    local current_status="$APP_DISABLE_SIGNUP"
    local new_status
    
    if [ "$current_status" = "true" ]; then
        new_status="false"
        print_status "Enabling user signups..."
    else
        new_status="true"
        print_status "Disabling user signups..."
    fi
    
    # Update .env file
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^APP_DISABLE_SIGNUP=.*/APP_DISABLE_SIGNUP=$new_status/" .env
    else
        sed -i "s/^APP_DISABLE_SIGNUP=.*/APP_DISABLE_SIGNUP=$new_status/" .env
    fi
    
    print_success "User signups now $([ "$new_status" = "true" ] && echo "disabled" || echo "enabled")"
    
    if port_in_use $BLOG_PORT; then
        print_warning "Restart blog application to apply changes"
    fi
}

test_api() {
    print_header "Testing API Endpoints"
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    print_status "Testing API endpoints..."
    
    echo -e "${CYAN}GET /api/users:${NC}"
    curl -s -H "Authorization: Bearer $API_TOKEN" "http://localhost:$BLOG_PORT/api/users" | jq '.' || echo "Failed"
    
    echo -e "${CYAN}GET /api/posts:${NC}"
    curl -s -H "Authorization: Bearer $API_TOKEN" "http://localhost:$BLOG_PORT/api/posts" | jq '.' || echo "Failed"
    
    echo -e "${CYAN}GET /:${NC}"
    curl -s "http://localhost:$BLOG_PORT/" | head -5 || echo "Failed"
}

# Build functions
build_app() {
    print_header "Building Blog Application"
    
    print_status "Building Go application..."
    go build -o tmp/blog
    
    if [ -f "tmp/blog" ]; then
        print_success "Build completed: tmp/blog"
    else
        print_error "Build failed"
        return 1
    fi
}

docker_build() {
    print_header "Building Docker Image"
    
    local platform=""
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # Mac - detect architecture
        if [[ $(uname -m) == "arm64" ]]; then
            platform="--platform=linux/arm64/v8"
        else
            platform="--platform=linux/amd64"
        fi
    else
        platform="--platform=linux/amd64"
    fi
    
    print_status "Building Docker image with platform: $platform"
    docker buildx build $platform --progress=plain -t biswas/blog:v0.1 .
    
    if [ $? -eq 0 ]; then
        print_success "Docker image built successfully"
    else
        print_error "Docker build failed"
        return 1
    fi
}

docker_run() {
    print_header "Running Blog in Docker"
    
    load_env
    
    # Stop existing container if running
    if docker ps --format "table {{.Names}}" | grep -q "^blog$"; then
        print_status "Stopping existing blog container..."
        docker stop blog
        docker rm blog
    fi
    
    print_status "Starting blog container..."
    docker run -d -p $BLOG_PORT:$BLOG_PORT --env-file .env --name blog -v $(pwd):/go/src/blog biswas/blog:v0.1
    
    sleep 3
    if docker ps --format "table {{.Names}}" | grep -q "^blog$"; then
        print_success "Blog container started at http://localhost:$BLOG_PORT"
    else
        print_error "Blog container failed to start"
        docker logs blog
    fi
}

# Utility functions
check_health() {
    print_header "Health Check"
    
    load_env
    
    # Check blog
    if port_in_use $BLOG_PORT; then
        if curl -f "http://localhost:$BLOG_PORT" >/dev/null 2>&1; then
            echo -e "${GREEN}✓ Blog Application${NC} - Healthy (http://localhost:$BLOG_PORT)"
        else
            echo -e "${YELLOW}⚠ Blog Application${NC} - Port open but not responding"
        fi
    else
        echo -e "${RED}✗ Blog Application${NC} - Not running"
    fi
    
    # Check database
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        if docker exec $DOCKER_CONTAINER_NAME pg_isready -U $PG_USER >/dev/null 2>&1; then
            echo -e "${GREEN}✓ PostgreSQL Database${NC} - Healthy (port $PG_PORT)"
        else
            echo -e "${YELLOW}⚠ PostgreSQL Database${NC} - Container running but database not ready"
        fi
    else
        echo -e "${RED}✗ PostgreSQL Database${NC} - Not running"
    fi
}

clean_files() {
    print_header "Cleaning Files"
    
    rm -rf "$LOG_DIR"/*.log
    rm -rf "$PID_DIR"/*.pid
    rm -rf tmp/
    
    print_success "Cleaned logs and temporary files"
}

show_ports() {
    print_header "Port Usage"
    
    load_env
    
    echo -e "${CYAN}Application Ports:${NC}"
    echo "  Blog Application: $BLOG_PORT"
    echo "  PostgreSQL Database: $PG_PORT"
    echo ""
    
    echo -e "${CYAN}Currently in use:${NC}"
    for port in $BLOG_PORT $PG_PORT; do
        if port_in_use $port; then
            pid=$(get_pid_by_port $port)
            echo -e "  Port $port: ${GREEN}✓ In use${NC} (PID: $pid)"
        else
            echo -e "  Port $port: ${RED}✗ Available${NC}"
        fi
    done
}

show_env() {
    print_header "Environment Variables"
    
    if [ -f ".env" ]; then
        echo -e "${CYAN}Current .env configuration:${NC}"
        cat .env | grep -v '^#' | while read line; do
            if [[ $line == *"PASSWORD"* ]] || [[ $line == *"TOKEN"* ]]; then
                echo "  $(echo $line | cut -d'=' -f1)=***hidden***"
            else
                echo "  $line"
            fi
        done
    else
        print_warning ".env file not found"
    fi
}

# Database query shortcuts
show_users() {
    execute_db_query "SELECT user_id, username, email, role_id FROM users ORDER BY user_id;"
}

show_posts() {
    execute_db_query "SELECT id, title, slug, is_published, created_at FROM posts ORDER BY id;"
}

show_roles() {
    execute_db_query "SELECT role_id, role_name, created_at FROM roles ORDER BY role_id;"
}

show_categories() {
    execute_db_query "SELECT category_id, category_name, created_at FROM categories ORDER BY category_id;"
}

# Main command handler
case ${1:-help} in
    start)
        print_header "Starting All Services"
        start_db "$2"
        start_blog "$2"
        echo ""
        show_status
        ;;
    stop)
        print_header "Stopping All Services"
        stop_blog
        stop_db
        ;;
    restart)
        print_header "Restarting All Services"
        stop_blog
        stop_db
        sleep 2
        start_db "$2"
        start_blog "$2"
        echo ""
        show_status
        ;;
    restart-blog)
        restart_blog
        ;;
    status)
        show_status
        ;;
    start-blog)
        start_blog "$2"
        ;;
    start-db)
        start_db "$2"
        ;;
    stop-blog)
        stop_blog
        ;;
    stop-db)
        stop_db
        ;;
    dev)
        start_db "$2"
        start_dev "$2"
        echo ""
        show_status
        ;;
    build)
        build_app
        ;;
    test-go)
        print_header "Running Go unit tests"
        go test -v ./tests/go
        ;;
    test-playwright)
        print_header "Running Playwright tests"
        node tests/playwright/test_admin_nav_playwright.js
        ;;
    test-all)
        print_header "Running All Tests"
        go test -v ./tests/go || exit 1
        echo ""
        node tests/playwright/test_admin_nav_playwright.js || exit 1
        print_success "All tests passed"
        ;;
    docker-build)
        docker_build
        ;;
    docker-run)
        docker_run
        ;;
    logs)
        show_logs "$2" "$3"
        ;;
    tail)
        tail_logs "$2" "$3"
        ;;
    db)
        if [ -n "$2" ]; then
            execute_db_query "$2"
        else
            show_posts
        fi
        ;;
    db-migrate)
        run_migrations
        ;;
    db-reset)
        reset_database
        ;;
    db-seed)
        seed_database
        ;;
    db-users)
        show_users
        ;;
    db-posts)
        show_posts
        ;;
    db-roles)
        show_roles
        ;;
    db-categories)
        show_categories
        ;;
    add-user)
        add_user "$2" "$3" "$4" "$5"
        ;;
    add-post)
        add_post "$2" "$3" "$4" "$5"
        ;;
    toggle-signup)
        toggle_signup
        ;;
    api-test)
        test_api
        ;;
    health)
        check_health
        ;;
    clean)
        clean_files
        ;;
    ports)
        show_ports
        ;;
    env)
        show_env
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        print_error "Unknown command: $1"
        echo ""
        show_help
        exit 1
        ;;
esac
