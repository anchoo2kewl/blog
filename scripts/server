#!/bin/bash

# Blog Local Server Management Script
# Manages blog backend, database, and related operations

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
BLOG_PORT=22222
DB_PORT=5433
LOG_DIR="./logs"
PID_DIR="./pids"
DOCKER_CONTAINER_NAME="pg"
DB_VOLUME_NAME="postgres-volume"

# Remote production settings
REMOTE_SERVER="ubuntu@anshumanbiswas.com"
REMOTE_DEPLOY_PATH="/home/ubuntu/projects/blog"
REMOTE_DB_CONTAINER="blog-postgres"
REMOTE_DOCKER_CONTAINER="blog-app"
REMOTE_DB_NAME="blog"
REMOTE_DB_USER="blog"

# Create directories if they don't exist
mkdir -p "$LOG_DIR" "$PID_DIR"

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_header() {
    echo -e "${BLUE}=== $1 ===${NC}"
}

# Function to show help
show_help() {
    echo -e "${CYAN}Blog Server Management Script${NC}"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo -e "${YELLOW}Server Commands:${NC}"
    echo "  start [--force]        Start all services (blog app, database)"
    echo "  stop                   Stop all services"
    echo "  restart [--force]      Restart all services"
    echo "  status                 Show status of all services"
    echo ""
    echo -e "${YELLOW}Individual Service Commands:${NC}"
    echo "  start-blog [--force]   Start blog application only"
    echo "  start-db [--force]     Start PostgreSQL database only"
    echo "  stop-blog              Stop blog application"
    echo "  stop-db                Stop PostgreSQL database"
    echo ""
    echo -e "${YELLOW}Development Commands:${NC}"
    echo "  dev [--force]          Start in development mode with air"
    echo "  build                  Build the blog application"
    echo "  docker-build           Build Docker image"
    echo "  docker-run             Run in Docker container"
    echo ""
    echo -e "${YELLOW}Log Commands:${NC}"
    echo "  logs [service]         Show logs for all services or specific service"
    echo "                         Services: blog, db, docker, all (default)"
    echo "  tail [service] [n]     Tail logs (default: 50 lines)"
    echo ""
    echo -e "${YELLOW}Database Commands:${NC}"
    echo "  db [query]             Execute SQL query on database"
    echo "  remote-db [query]      Execute SQL query on REMOTE production database"
    echo "  remote-logs [service]  View logs from REMOTE production server (nginx/blog/system)"
    echo "  db-migrate             Run database migrations"
    echo "  db-reset               Reset database (drop and recreate)"
    echo "  db-seed                Load test data into database"
    echo "  db-users               Show all users"
    echo "  db-posts               Show all posts"
    echo "  db-roles               Show all roles"
    echo "  db-categories          Show all categories"
    echo ""
    echo -e "${YELLOW}API Commands:${NC}"
    echo "  add-user <email> <username> <password> [role_name] Add new user (role: admin, editor, commenter, viewer)"
    echo "  add-post <title> <content> [user_id] [category_ids] [featured_image] Create new post with multiple categories"
    echo "  add-post-from-file <file_path> [title] [category_id] [featured_image] Create post from external file"
    echo "  upload-multiple-images <file1> <file2> ... [slug] Upload multiple images with preview"
    echo "  add-category <name>    Create a new category"
    echo "  assign-categories <post_id> <category_ids> Assign multiple categories to a post"
    echo "  upload-image <file_path> [alt_text] Upload image and return URL"
    echo "  toggle-signup          Enable/disable user signups"
    echo "  api-test               Test API endpoints"
    echo ""
    echo -e "${YELLOW}Content Commands:${NC}"
    echo "  demo-post [title]      Create a formatting showcase post directly in DB"
    echo -e "${YELLOW}Utility Commands:${NC}"
    echo "  health                 Check health of all services"
    echo "  clean                  Clean logs and temporary files"
    echo "  ports                  Show which ports are in use"
    echo "  env                    Show environment variables"
    echo ""
    echo -e "${YELLOW}Test Commands:${NC}"
    echo "  test-go                Run Go unit tests in tests/go"
    echo "  test-playwright        Run Playwright tests in tests/playwright"
    echo "  test-all               Run Go + Playwright tests"
    echo ""
    echo -e "${YELLOW}Deployment Commands:${NC}"
    echo "  deploy [commit_msg]    Deploy to production server (ubuntu@anshumanbiswas.com)"
    echo "                         Optional commit message for uncommitted changes"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  $0 start --force                                    # Force start all services"
    echo "  $0 dev --force                                      # Start in dev mode"
    echo "  $0 add-user user@example.com john password123 admin # Add admin user"
    echo "  $0 add-category \"Machine Learning\"                # Create new category"
    echo "  $0 add-post \"My Post\" \"Content\" 1 \"2,3,4\"       # Add post with categories 2,3,4"
    echo "  $0 add-post-from-file ./my-post.md \"My Post\" 1 /static/cover.jpg # Create post from markdown file"
    echo "  $0 upload-multiple-images img1.jpg img2.png img3.gif my-post-slug # Upload multiple images"
    echo "  $0 assign-categories 5 \"1,2,3\"                   # Assign categories 1,2,3 to post 5"
    echo "  $0 upload-image ./image.jpg \"Alt text\"             # Upload image"
    echo "  $0 db \"SELECT * FROM users LIMIT 5;\"             # Execute SQL query"
    echo "  $0 logs blog                                        # Show blog logs"
    echo "  $0 tail db 100                                      # Tail database logs"
    echo "  $0 deploy \"fix: resolve authentication bug\"       # Deploy with custom commit message"
}

# Function to load environment variables
load_env() {
    if [ -f ".env" ]; then
        export $(cat .env | grep -v '^#' | xargs)
    else
        print_error ".env file not found"
        return 1
    fi
}

# Function to check if a port is in use
port_in_use() {
    lsof -i :$1 >/dev/null 2>&1
}

# Function to get PID using a port
get_pid_by_port() {
    lsof -ti :$1 2>/dev/null || echo ""
}

# Function to kill process by port
kill_by_port() {
    local port=$1
    local service=$2
    local pid=$(get_pid_by_port $port)
    
    if [ -n "$pid" ]; then
        print_status "Stopping $service (PID: $pid) on port $port..."
        kill $pid 2>/dev/null || true
        sleep 2
        
        # Force kill if still running
        if kill -0 $pid 2>/dev/null; then
            print_warning "Force killing $service..."
            kill -9 $pid 2>/dev/null || true
        fi
        print_success "$service stopped"
    else
        print_warning "$service not running on port $port"
    fi
}

# Function to start PostgreSQL database
start_db() {
    local force=false
    if [ "$1" = "--force" ]; then
        force=true
    fi
    
    print_header "Starting PostgreSQL Database"
    
    # Check if Docker container exists
    if docker ps -a --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
            if [ "$force" = true ]; then
                print_warning "Force stopping existing database container..."
                docker stop $DOCKER_CONTAINER_NAME
                sleep 2
            else
                print_warning "Database already running (use --force to restart)"
                return
            fi
        else
            print_status "Starting existing container..."
            docker start $DOCKER_CONTAINER_NAME
        fi
    else
        load_env
        print_status "Creating new PostgreSQL container..."
        
        # Create volume if it doesn't exist
        if ! docker volume ls | grep -q $DB_VOLUME_NAME; then
            docker volume create $DB_VOLUME_NAME
        fi
        
        docker run --name $DOCKER_CONTAINER_NAME \
            -e POSTGRES_PASSWORD=$PG_PASSWORD \
            -e POSTGRES_USER=$PG_USER \
            -p $PG_PORT:5432 \
            -v $DB_VOLUME_NAME:/var/lib/postgresql/data \
            -d postgres > "$LOG_DIR/docker.log" 2>&1
    fi
    
    # Wait for startup
    sleep 5
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_success "Database started on port $PG_PORT"
    else
        print_error "Database failed to start"
        print_status "Check logs with: $0 logs db"
    fi
}

# Function to start blog application
start_blog() {
    local force=false
    if [ "$1" = "--force" ]; then
        force=true
    fi
    
    print_header "Starting Blog Application"
    
    if port_in_use $BLOG_PORT; then
        if [ "$force" = true ]; then
            print_warning "Force stopping existing blog application..."
            kill_by_port $BLOG_PORT "Blog Application"
            sleep 2
        else
            print_warning "Blog already running on port $BLOG_PORT (use --force to restart)"
            return
        fi
    fi
    
    load_env
    
    # Build application if binary doesn't exist
    if [ ! -f "tmp/blog" ]; then
        print_status "Building application..."
        go build -o tmp/blog
    fi
    
    print_status "Starting blog application on port $BLOG_PORT..."
    nohup ./tmp/blog --listen-addr :$BLOG_PORT > "$LOG_DIR/blog.log" 2>&1 &
    echo $! > "$PID_DIR/blog.pid"
    
    # Wait for startup
    sleep 3
    if port_in_use $BLOG_PORT; then
        print_success "Blog application started at http://localhost:$BLOG_PORT"
    else
        print_error "Blog application failed to start"
        print_status "Check logs with: $0 logs blog"
    fi
}

# Function to start in development mode with air
start_dev() {
    local force=false
    if [ "$1" = "--force" ]; then
        force=true
    fi
    
    print_header "Starting Blog in Development Mode"
    
    if port_in_use $BLOG_PORT; then
        if [ "$force" = true ]; then
            print_warning "Force stopping existing blog application..."
            kill_by_port $BLOG_PORT "Blog Application"
            sleep 2
        else
            print_warning "Blog already running on port $BLOG_PORT (use --force to restart)"
            return
        fi
    fi
    
    load_env
    
    # Check if air is installed
    if ! command -v air >/dev/null 2>&1; then
        if ! command -v ~/go/bin/air >/dev/null 2>&1; then
            print_error "Air not found. Installing..."
            curl -sSfL https://raw.githubusercontent.com/cosmtrek/air/master/install.sh | sh -s -- -b $(go env GOPATH)/bin
        fi
    fi
    
    print_status "Starting blog with air (live reloading) on port $BLOG_PORT..."
    nohup ~/go/bin/air -c .air.toml > "$LOG_DIR/blog-dev.log" 2>&1 &
    echo $! > "$PID_DIR/blog-dev.pid"
    
    # Wait for startup
    sleep 5
    if port_in_use $BLOG_PORT; then
        print_success "Blog development server started at http://localhost:$BLOG_PORT"
        print_status "Live reloading enabled - changes will trigger rebuilds"
    else
        print_error "Blog development server failed to start"
        print_status "Check logs with: $0 logs blog"
    fi
}

# Function to restart only the blog app and rebuild binary (ensures embedded templates refresh)
restart_blog() {
    print_header "Rebuilding and Restarting Blog Application"
    # Stop if running
    if port_in_use $BLOG_PORT; then
        kill_by_port $BLOG_PORT "Blog Application"
        sleep 1
    fi
    # Rebuild fresh binary
    print_status "Rebuilding application binary..."
    rm -f tmp/blog || true
    go build -o tmp/blog
    # Start
    start_blog --force
}

# Function to stop services
stop_blog() {
    print_header "Stopping Blog Application"
    kill_by_port $BLOG_PORT "Blog Application"
    rm -f "$PID_DIR/blog.pid" "$PID_DIR/blog-dev.pid"
}

stop_db() {
    print_header "Stopping PostgreSQL Database"
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        docker stop $DOCKER_CONTAINER_NAME
        print_success "Database stopped"
    else
        print_warning "Database not running"
    fi
}

# Function to show service status
show_status() {
    print_header "Service Status"
    
    echo -e "${CYAN}Blog Application:${NC}"
    if port_in_use $BLOG_PORT; then
        echo -e "  ${GREEN}✓ Running${NC} on port $BLOG_PORT (http://localhost:$BLOG_PORT)"
    else
        echo -e "  ${RED}✗ Not running${NC}"
    fi
    
    echo -e "${CYAN}PostgreSQL Database:${NC}"
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        load_env
        echo -e "  ${GREEN}✓ Running${NC} on port $PG_PORT (Container: $DOCKER_CONTAINER_NAME)"
    else
        echo -e "  ${RED}✗ Not running${NC}"
    fi
}

# Function to show logs
show_logs() {
    local service=${1:-all}
    local lines=${2:-50}
    
    case $service in
        blog)
            if [ -f "$LOG_DIR/blog.log" ]; then
                print_header "Blog Application Logs (last $lines lines)"
                tail -n $lines "$LOG_DIR/blog.log"
            elif [ -f "$LOG_DIR/blog-dev.log" ]; then
                print_header "Blog Development Logs (last $lines lines)"
                tail -n $lines "$LOG_DIR/blog-dev.log"
            else
                print_warning "Blog logs not found"
            fi
            ;;
        db|docker)
            if [ -f "$LOG_DIR/docker.log" ]; then
                print_header "Database Logs (last $lines lines)"
                tail -n $lines "$LOG_DIR/docker.log"
            else
                print_warning "Database logs not found"
            fi
            # Also show Docker container logs
            if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
                print_header "PostgreSQL Container Logs (last $lines lines)"
                docker logs --tail $lines $DOCKER_CONTAINER_NAME
            fi
            ;;
        all|*)
            print_header "All Service Logs (last $lines lines each)"
            show_logs blog $lines
            echo ""
            show_logs db $lines
            ;;
    esac
}

# Function to tail logs
tail_logs() {
    local service=${1:-blog}
    local lines=${2:-50}
    
    case $service in
        blog)
            if [ -f "$LOG_DIR/blog.log" ]; then
                print_header "Tailing Blog Application Logs"
                tail -f -n $lines "$LOG_DIR/blog.log"
            elif [ -f "$LOG_DIR/blog-dev.log" ]; then
                print_header "Tailing Blog Development Logs"
                tail -f -n $lines "$LOG_DIR/blog-dev.log"
            else
                print_warning "Blog logs not found"
            fi
            ;;
        db|docker)
            print_header "Tailing Database Container Logs"
            if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
                docker logs -f --tail $lines $DOCKER_CONTAINER_NAME
            else
                print_warning "Database container not running"
            fi
            ;;
        *)
            print_error "Cannot tail logs for service: $service. Choose: blog, db"
            ;;
    esac
}

# Database functions
execute_db_query() {
    local query="$1"
    
    load_env
    
    print_header "Database Query"
    echo -e "${CYAN}Query:${NC} $query"
    echo ""
    
    if ! docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_error "Database not running. Start with: $0 start-db"
        return 1
    fi
    
    docker exec $DOCKER_CONTAINER_NAME psql -U $PG_USER -d $PG_DB -c "$query"
}

# Execute SQL on remote production database via SSH safely (supports quotes/newlines)
execute_remote_db_query() {
    local query="$1"

    if [ -z "$query" ]; then
        print_error "Usage: $0 remote-db \"SQL_QUERY\""
        return 1
    fi

    print_header "Remote Database Query"
    echo -e "${CYAN}Server:${NC} $REMOTE_SERVER"
    echo -e "${CYAN}Query:${NC} $query"
    echo ""

    # Verify SSH connectivity
    if ! ssh -o ConnectTimeout=10 "$REMOTE_SERVER" "echo ok" >/dev/null 2>&1; then
        print_error "Cannot connect to $REMOTE_SERVER"
        return 1
    fi

    # Feed SQL via stdin to avoid quoting issues
    ssh "$REMOTE_SERVER" "cd '$REMOTE_DEPLOY_PATH' && docker exec -i '$REMOTE_DB_CONTAINER' psql -U '$REMOTE_DB_USER' -d '$REMOTE_DB_NAME' -v ON_ERROR_STOP=1" <<SQL
$query
SQL
}

view_remote_logs() {
    local service="${1:-blog}"
    
    print_header "Remote Production Logs"
    echo -e "${CYAN}Server:${NC} $REMOTE_SERVER"
    echo -e "${CYAN}Service:${NC} $service"
    echo ""
    
    # Verify SSH connectivity
    if ! ssh -o ConnectTimeout=10 "$REMOTE_SERVER" "echo ok" >/dev/null 2>&1; then
        print_error "Cannot connect to $REMOTE_SERVER"
        return 1
    fi
    
    case "$service" in
        blog)
            print_status "Showing blog application logs..."
            ssh "$REMOTE_SERVER" "cd '$REMOTE_DEPLOY_PATH' && docker logs --tail=100 -f '$REMOTE_DOCKER_CONTAINER'"
            ;;
        nginx)
            print_status "Showing nginx logs..."
            ssh "$REMOTE_SERVER" "sudo tail -f /var/log/nginx/access.log /var/log/nginx/error.log"
            ;;
        system)
            print_status "Showing system logs..."
            ssh "$REMOTE_SERVER" "sudo journalctl -f -n 100"
            ;;
        *)
            print_error "Unknown service: $service"
            echo "Available services: blog, nginx, system"
            return 1
            ;;
    esac
}

run_migrations() {
    print_header "Running Database Migrations"
    
    load_env
    
    if ! command -v migrate >/dev/null 2>&1; then
        print_error "golang-migrate not installed. Install with: brew install golang-migrate"
        return 1
    fi
    
    if ! docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_error "Database not running. Start with: $0 start-db"
        return 1
    fi
    
    migrate -source file://migrations -database "postgresql://$PG_USER:$PG_PASSWORD@$PG_HOST:$PG_PORT/$PG_DB?sslmode=disable" up
    print_success "Migrations completed"
}

# Create a rich demo post directly in DB using SQL dollar-quoting
create_demo_post() {
    load_env
    if ! docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_error "Database not running. Start with: $0 start-db"
        return 1
    fi

    local title="${1:-Formatting Showcase}"
    local user_id="${2:-2}"
    local category_id="${3:-1}"

    # slugify title
    local slug=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')

    # Multi-line content covering most formatting options
    local content=$(cat << 'EOF'
Welcome to the formatting showcase! This paragraph demonstrates **bold**, *italic*, and `inline code`, plus a [link](https://example.com).

<more-->

## Headings (H2)
### Subheading (H3)

> A blockquote with emphasis.

- Unordered item A
- Unordered item B
  - Nested item B1

1. Ordered item 1
2. Ordered item 2
   1. Nested 2.1

| Feature | Status | Priority |
|--------:|:------:|:--------|
| Lists   | ✅     | High     |
| Tables  | ✅     | High     |

```python
class DatabaseConnection:
    def __init__(self, host, port, database):
        self.host = host
        self.port = port
        self.database = database
        self.connection = None

    async def connect(self):
        """Establish database connection"""
        self.connection = await asyncpg.connect(
            host=self.host,
            port=self.port,
            database=self.database
        )
```

```css
pre code{ font-variant-ligatures: none; }
.token.keyword{ color:#93C5FD; }
```

```go
package main
import "fmt"
func main(){ fmt.Println("Hello, formatting!") }
```

Inline image:
<img src="/static/placeholder-featured.svg" alt="Placeholder" style="max-width:480px" />

---

That concludes the demo. Happy writing!
EOF
)

    # Escape single quotes for SQL literal
    local esc_content=$(printf "%s" "$content" | sed "s/'/''/g")

    print_header "Creating demo post: $title"
    docker exec -i $DOCKER_CONTAINER_NAME psql -U $PG_USER -d $PG_DB -v ON_ERROR_STOP=1 <<SQL
INSERT INTO posts (user_id, category_id, title, content, slug, publication_date, last_edit_date, is_published, featured_image_url, created_at)
VALUES ($user_id, $category_id, '$title',
'$esc_content',
'$slug', NOW(), NOW(), true, '/static/placeholder-featured.svg', NOW());
SQL

print_success "Demo post created: $title (/$slug)"
}

reset_database() {
    print_header "Resetting Database"
    
    echo -e "${RED}WARNING: This will delete all data!${NC}"
    read -p "Are you sure? Type 'yes' to confirm: " confirm
    
    if [ "$confirm" != "yes" ]; then
        print_status "Operation cancelled"
        return
    fi
    
    load_env
    
    # Stop database
    stop_db
    
    # Remove volume
    if docker volume ls | grep -q $DB_VOLUME_NAME; then
        print_status "Removing database volume..."
        docker volume rm $DB_VOLUME_NAME
    fi
    
    # Remove container
    if docker ps -a --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_status "Removing database container..."
        docker rm $DOCKER_CONTAINER_NAME
    fi
    
    # Start fresh
    start_db
    sleep 5
    run_migrations
    print_success "Database reset completed"
}

seed_database() {
    print_header "Seeding Database with Test Data"
    
    if [ -f "db_test.sh" ]; then
        print_status "Running test data script..."
        # Modify db_test.sh to work with our setup
        load_env
        
        # Insert roles
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Commenter') ON CONFLICT DO NOTHING;"
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Administrator') ON CONFLICT DO NOTHING;"
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Editor') ON CONFLICT DO NOTHING;"
        execute_db_query "INSERT INTO ROLES (role_name) VALUES ('Viewer') ON CONFLICT DO NOTHING;"
        
        # Insert category
        execute_db_query "INSERT INTO CATEGORIES (category_name) VALUES ('Demo Category') ON CONFLICT DO NOTHING;"
        
        # Add users via API if blog is running
        if port_in_use $BLOG_PORT; then
            print_status "Adding test users via API..."
            add_user "anshuman@biswas.me" "anshuman" "123456qwertyu" 1
            add_user "anchoo2kewl@gmail.com" "anchoo2kewl" "123456qwertyu" 2
            
            print_status "Adding test posts via API..."
            add_post "Fictitious Blog Post" "Lorem ipsum dolor sit amet, consectetur adipiscing elit..." 2 1
            add_post "Exploring the Cosmos" "Curabitur dictum malesuada massa, eu tempor leo sagittis nec..." 2 1
        else
            print_warning "Blog not running. Start blog first to add users/posts via API"
        fi
        
        print_success "Database seeded with test data"
    else
        print_warning "db_test.sh not found"
    fi
}

# API functions
add_user() {
    local email="$1"
    local username="$2"
    local password="$3"
    local role_name="${4:-commenter}"
    
    if [ -z "$email" ] || [ -z "$username" ] || [ -z "$password" ]; then
        print_error "Usage: add_user <email> <username> <password> [role_name]"
        print_error "Available roles: admin, administrator, editor, commenter, viewer"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    # Resolve role name to role ID
    local role_id
    # Convert to lowercase using tr
    local role_lower=$(echo "$role_name" | tr '[:upper:]' '[:lower:]')
    case "$role_lower" in
        "admin"|"administrator")
            role_id=2
            ;;
        "editor")
            role_id=3
            ;;
        "commenter")
            role_id=1
            ;;
        "viewer")
            role_id=4
            ;;
        [0-9]*)
            role_id="$role_name"  # If numeric, use as-is for backward compatibility
            ;;
        *)
            print_error "Invalid role: $role_name"
            print_error "Available roles: admin, administrator, editor, commenter, viewer"
            return 1
            ;;
    esac
    
    print_status "Adding user: $username ($email) with role: $role_name (ID: $role_id)"
    
    local response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_TOKEN" \
        -d "{\"email\":\"$email\",\"username\":\"$username\",\"password\":\"$password\",\"role\":$role_id}" \
        "http://localhost:$BLOG_PORT/api/users")
    
    if echo "$response" | jq . >/dev/null 2>&1; then
        echo "$response" | jq .
    else
        echo "Response: $response"
    fi
}

add_post() {
    local title="$1"
    local content="$2"
    local user_id="${3:-2}"
    local category_id="${4:-1}"
    
    if [ -z "$title" ] || [ -z "$content" ]; then
        print_error "Usage: add_post <title> <content> [user_id] [category_id]"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    # Generate slug from title
    local slug=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
    
    print_status "Adding post: $title"
    
    curl -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_TOKEN" \
        -d "{\"userID\":$user_id,\"categoryID\":$category_id,\"title\":\"$title\",\"slug\":\"$slug\",\"content\":\"$content\",\"isPublished\":true}" \
        "http://localhost:$BLOG_PORT/api/posts" | jq '.' || echo ""
}

# Enhanced category management functions
add_category() {
    local name="$1"
    
    if [ -z "$name" ]; then
        print_error "Usage: add_category <name>"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    print_status "Creating category: $name"
    
    local response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $API_TOKEN" \
        -d "{\"name\":\"$name\"}" \
        "http://localhost:$BLOG_PORT/api/categories")
    
    if echo "$response" | jq . >/dev/null 2>&1; then
        print_success "Category created successfully"
        echo "$response" | jq .
    else
        print_error "Failed to create category"
        echo "Response: $response"
        return 1
    fi
}

assign_categories() {
    local post_id="$1"
    local category_ids="$2" # Comma-separated like "1,2,3"
    
    if [ -z "$post_id" ] || [ -z "$category_ids" ]; then
        print_error "Usage: assign_categories <post_id> <category_ids>"
        print_error "  category_ids should be comma-separated: 1,2,3"
        return 1
    fi
    
    load_env
    
    if ! docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        print_error "Database not running. Start with: $0 start-db"
        return 1
    fi
    
    print_status "Assigning categories [$category_ids] to post $post_id"
    
    # First, clear existing categories for this post
    docker exec $DOCKER_CONTAINER_NAME psql -U $PG_USER -d $PG_DB -c \
        "DELETE FROM post_categories WHERE post_id = $post_id;"
    
    # Split category_ids and insert each one
    IFS=',' read -ra CATEGORIES <<< "$category_ids"
    for category_id in "${CATEGORIES[@]}"; do
        category_id=$(echo "$category_id" | xargs) # Trim whitespace
        print_status "  Assigning category $category_id..."
        docker exec $DOCKER_CONTAINER_NAME psql -U $PG_USER -d $PG_DB -c \
            "INSERT INTO post_categories (post_id, category_id) VALUES ($post_id, $category_id) ON CONFLICT DO NOTHING;"
    done
    
    print_success "Categories assigned successfully"
    
    # Show the result
    print_status "Post categories:"
    docker exec $DOCKER_CONTAINER_NAME psql -U $PG_USER -d $PG_DB -c \
        "SELECT pc.post_id, p.title, c.category_name FROM post_categories pc JOIN posts p ON pc.post_id = p.post_id JOIN categories c ON pc.category_id = c.category_id WHERE pc.post_id = $post_id;"
}

# File-based post creation function
add_post_from_file() {
    local file_path="$1"
    local title="$2"
    local category_id="${3:-1}"
    local featured_image_url="$4"
    
    if [ -z "$file_path" ]; then
        print_error "Usage: add_post_from_file <file_path> [title] [category_id] [featured_image_url]"
        return 1
    fi
    
    if [ ! -f "$file_path" ]; then
        print_error "File not found: $file_path"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    print_status "Creating post from file: $(basename "$file_path")"
    
    local response=$(curl -s -X POST \
        -H "Authorization: Bearer $API_TOKEN" \
        -F "file=@$file_path" \
        -F "title=$title" \
        -F "user_id=2" \
        -F "category_id=$category_id" \
        -F "featured_image_url=$featured_image_url" \
        -F "is_published=true" \
        "http://localhost:$BLOG_PORT/api/posts/from-file")
    
    if echo "$response" | jq . >/dev/null 2>&1; then
        if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            print_success "Post created successfully"
            echo "$response" | jq .
        else
            print_error "Failed to create post"
            echo "$response" | jq .
            return 1
        fi
    else
        print_error "Failed to create post"
        echo "Response: $response"
        return 1
    fi
}

# Multiple image upload function  
upload_multiple_images() {
    if [ $# -lt 1 ]; then
        print_error "Usage: upload_multiple_images <file1> [file2] [file3] ... [slug]"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    # Last argument might be slug if it doesn't exist as a file
    local files=()
    local slug=""
    
    for arg in "$@"; do
        if [ -f "$arg" ]; then
            files+=("$arg")
        else
            slug="$arg"
        fi
    done
    
    if [ ${#files[@]} -eq 0 ]; then
        print_error "No valid image files provided"
        return 1
    fi
    
    print_status "Uploading ${#files[@]} images..."
    
    # Build curl command with multiple files
    local curl_cmd=(curl -s -X POST -H "Authorization: Bearer $API_TOKEN")
    
    for file in "${files[@]}"; do
        curl_cmd+=(-F "files=@$file")
    done
    
    if [ -n "$slug" ]; then
        curl_cmd+=("http://localhost:$BLOG_PORT/admin/uploads/multiple?slug=$slug")
    else
        curl_cmd+=("http://localhost:$BLOG_PORT/admin/uploads/multiple")
    fi
    
    local response=$("${curl_cmd[@]}")
    
    if echo "$response" | jq . >/dev/null 2>&1; then
        local success_count=$(echo "$response" | jq -r '.success // 0')
        local total_count=$(echo "$response" | jq -r '.total // 0')
        
        if [ "$success_count" -gt 0 ]; then
            print_success "Successfully uploaded $success_count/$total_count images"
            echo "$response" | jq -r '.uploads[] | "  ✓ \(.filename) -> \(.url)"'
            
            local errors=$(echo "$response" | jq -r '.errors[]?' 2>/dev/null)
            if [ -n "$errors" ]; then
                echo ""
                print_warning "Errors:"
                echo "$response" | jq -r '.errors[] | "  ✗ \(.)"'
            fi
        else
            print_error "No images were uploaded successfully"
            echo "$response" | jq .
            return 1
        fi
    else
        print_error "Failed to upload images"
        echo "Response: $response"
        return 1
    fi
}

# Image upload function
upload_image() {
    local file_path="$1"
    local alt_text="${2:-Uploaded image}"
    
    if [ -z "$file_path" ]; then
        print_error "Usage: upload_image <file_path> [alt_text]"
        return 1
    fi
    
    if [ ! -f "$file_path" ]; then
        print_error "File not found: $file_path"
        return 1
    fi
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    print_status "Uploading image: $(basename "$file_path")"
    
    # Upload via the admin uploads endpoint
    local response=$(curl -s -X POST \
        -H "Authorization: Bearer $API_TOKEN" \
        -F "file=@$file_path" \
        -F "alt=$alt_text" \
        "http://localhost:$BLOG_PORT/admin/uploads")
    
    # Check if upload was successful
    if echo "$response" | grep -q "success\|uploaded\|/static/"; then
        # Extract URL from response (assuming JSON response with url field)
        local upload_url
        if echo "$response" | jq . >/dev/null 2>&1; then
            upload_url=$(echo "$response" | jq -r '.url // .path // .filename')
        else
            # Fallback: extract URL pattern from response
            upload_url=$(echo "$response" | grep -o '/static/uploads/[^"]*' | head -1)
        fi
        
        if [ -n "$upload_url" ]; then
            print_success "Image uploaded successfully: $upload_url"
            echo "$upload_url"
            return 0
        fi
    fi
    
    print_error "Failed to upload image"
    echo "Response: $response"
    return 1
}

toggle_signup() {
    load_env
    
    print_header "Toggle User Signups"
    
    local current_status="$APP_DISABLE_SIGNUP"
    local new_status
    
    if [ "$current_status" = "true" ]; then
        new_status="false"
        print_status "Enabling user signups..."
    else
        new_status="true"
        print_status "Disabling user signups..."
    fi
    
    # Update .env file
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "s/^APP_DISABLE_SIGNUP=.*/APP_DISABLE_SIGNUP=$new_status/" .env
    else
        sed -i "s/^APP_DISABLE_SIGNUP=.*/APP_DISABLE_SIGNUP=$new_status/" .env
    fi
    
    print_success "User signups now $([ "$new_status" = "true" ] && echo "disabled" || echo "enabled")"
    
    if port_in_use $BLOG_PORT; then
        print_warning "Restart blog application to apply changes"
    fi
}

test_api() {
    print_header "Testing API Endpoints"
    
    load_env
    
    if ! port_in_use $BLOG_PORT; then
        print_error "Blog not running. Start with: $0 start-blog"
        return 1
    fi
    
    print_status "Testing API endpoints..."
    
    echo -e "${CYAN}GET /api/users:${NC}"
    curl -s -H "Authorization: Bearer $API_TOKEN" "http://localhost:$BLOG_PORT/api/users" | jq '.' || echo "Failed"
    
    echo -e "${CYAN}GET /api/posts:${NC}"
    curl -s -H "Authorization: Bearer $API_TOKEN" "http://localhost:$BLOG_PORT/api/posts" | jq '.' || echo "Failed"
    
    echo -e "${CYAN}GET /:${NC}"
    curl -s "http://localhost:$BLOG_PORT/" | head -5 || echo "Failed"
}

# Build functions
build_app() {
    print_header "Building Blog Application"
    
    print_status "Building Go application..."
    go build -o tmp/blog
    
    if [ -f "tmp/blog" ]; then
        print_success "Build completed: tmp/blog"
    else
        print_error "Build failed"
        return 1
    fi
}

docker_build() {
    print_header "Building Docker Image"
    
    local platform=""
    if [[ "$OSTYPE" == "darwin"* ]]; then
        # Mac - detect architecture
        if [[ $(uname -m) == "arm64" ]]; then
            platform="--platform=linux/arm64/v8"
        else
            platform="--platform=linux/amd64"
        fi
    else
        platform="--platform=linux/amd64"
    fi
    
    print_status "Building Docker image with platform: $platform"
    docker buildx build $platform --progress=plain -t biswas/blog:v0.1 .
    
    if [ $? -eq 0 ]; then
        print_success "Docker image built successfully"
    else
        print_error "Docker build failed"
        return 1
    fi
}

docker_run() {
    print_header "Running Blog in Docker"
    
    load_env
    
    # Stop existing container if running
    if docker ps --format "table {{.Names}}" | grep -q "^blog$"; then
        print_status "Stopping existing blog container..."
        docker stop blog
        docker rm blog
    fi
    
    print_status "Starting blog container..."
    docker run -d -p $BLOG_PORT:$BLOG_PORT --env-file .env --name blog -v $(pwd):/go/src/blog biswas/blog:v0.1
    
    sleep 3
    if docker ps --format "table {{.Names}}" | grep -q "^blog$"; then
        print_success "Blog container started at http://localhost:$BLOG_PORT"
    else
        print_error "Blog container failed to start"
        docker logs blog
    fi
}

# Utility functions
check_health() {
    print_header "Health Check"
    
    load_env
    
    # Check blog
    if port_in_use $BLOG_PORT; then
        if curl -f "http://localhost:$BLOG_PORT" >/dev/null 2>&1; then
            echo -e "${GREEN}✓ Blog Application${NC} - Healthy (http://localhost:$BLOG_PORT)"
        else
            echo -e "${YELLOW}⚠ Blog Application${NC} - Port open but not responding"
        fi
    else
        echo -e "${RED}✗ Blog Application${NC} - Not running"
    fi
    
    # Check database
    if docker ps --format "table {{.Names}}" | grep -q "^${DOCKER_CONTAINER_NAME}$"; then
        if docker exec $DOCKER_CONTAINER_NAME pg_isready -U $PG_USER >/dev/null 2>&1; then
            echo -e "${GREEN}✓ PostgreSQL Database${NC} - Healthy (port $PG_PORT)"
        else
            echo -e "${YELLOW}⚠ PostgreSQL Database${NC} - Container running but database not ready"
        fi
    else
        echo -e "${RED}✗ PostgreSQL Database${NC} - Not running"
    fi
}

clean_files() {
    print_header "Cleaning Files"
    
    rm -rf "$LOG_DIR"/*.log
    rm -rf "$PID_DIR"/*.pid
    rm -rf tmp/
    
    print_success "Cleaned logs and temporary files"
}

show_ports() {
    print_header "Port Usage"
    
    load_env
    
    echo -e "${CYAN}Application Ports:${NC}"
    echo "  Blog Application: $BLOG_PORT"
    echo "  PostgreSQL Database: $PG_PORT"
    echo ""
    
    echo -e "${CYAN}Currently in use:${NC}"
    for port in $BLOG_PORT $PG_PORT; do
        if port_in_use $port; then
            pid=$(get_pid_by_port $port)
            echo -e "  Port $port: ${GREEN}✓ In use${NC} (PID: $pid)"
        else
            echo -e "  Port $port: ${RED}✗ Available${NC}"
        fi
    done
}

show_env() {
    print_header "Environment Variables"
    
    if [ -f ".env" ]; then
        echo -e "${CYAN}Current .env configuration:${NC}"
        cat .env | grep -v '^#' | while read line; do
            if [[ $line == *"PASSWORD"* ]] || [[ $line == *"TOKEN"* ]]; then
                echo "  $(echo $line | cut -d'=' -f1)=***hidden***"
            else
                echo "  $line"
            fi
        done
    else
        print_warning ".env file not found"
    fi
}

# Database query shortcuts
show_users() {
    execute_db_query "SELECT user_id, username, email, role_id FROM users ORDER BY user_id;"
}

show_posts() {
    execute_db_query "SELECT id, title, slug, is_published, created_at FROM posts ORDER BY id;"
}

show_roles() {
    execute_db_query "SELECT role_id, role_name, created_at FROM roles ORDER BY role_id;"
}

show_categories() {
    execute_db_query "SELECT category_id, category_name, created_at FROM categories ORDER BY category_id;"
}

# Deployment function
deploy_to_production() {
    print_header "Deploying to Production Server"
    
    local SERVER="ubuntu@anshumanbiswas.com"
    local DEPLOY_PATH="/home/ubuntu/projects/blog"
    local DOMAIN="anshumanbiswas.com"
    local commit_message="${1:-Deploy: automated commit before deployment}"
    
    # Step 1: Commit any changes on production server first
    print_status "Checking for changes on production server..."
    ssh "$SERVER" "cd '$DEPLOY_PATH' && if [ -n \"\$(git status --porcelain)\" ]; then
        echo 'Production changes detected, committing...'
        git add .
        git commit -m 'Production: commit uploaded files and changes

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>' || echo 'Commit failed or no changes'
        git push origin main || echo 'Push from production failed'
    else
        echo 'No changes on production server'
    fi"
    
    # Step 2: Pull any changes from remote (including production uploads)
    print_status "Pulling latest changes from remote..."
    git fetch origin
    git merge origin/main --no-edit || {
        print_warning "Merge conflicts detected. Please resolve manually and retry deployment."
        return 1
    }
    
    # Step 3: Check if there are local changes to commit
    print_status "Checking local git status..."
    if [ -n "$(git status --porcelain)" ]; then
        print_status "Local changes detected, committing all changes..."
        git add .
        git commit -m "$commit_message

🤖 Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>" || {
            print_error "Failed to commit local changes"
            return 1
        }
    fi
    
    # Step 4: Push to remote
    print_status "Pushing to git remote..."
    git push origin main || {
        print_error "Failed to push to git remote"
        return 1
    }
    
    # Test SSH connection
    print_status "Testing SSH connection..."
    ssh -o ConnectTimeout=10 "$SERVER" "echo 'SSH connection successful'" || {
        print_error "Cannot connect to $SERVER"
        return 1
    }
    
    # Create remote deployment script
    print_status "Creating remote deployment script..."
    cat << 'EOF' | ssh "$SERVER" "cat > /tmp/deploy_blog.sh && chmod +x /tmp/deploy_blog.sh"
#!/bin/bash
set -e

DEPLOY_PATH="/home/ubuntu/projects/blog"
DOMAIN="anshumanbiswas.com"
REPO_URL="git@github.com:anchoo2kewl/blog.git"

# Colors
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

print_status() { echo -e "${GREEN}[INFO]${NC} $1"; }
print_error() { echo -e "${RED}[ERROR]${NC} $1"; }
print_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Update system packages
print_status "Updating system packages..."
sudo apt-get update -y
sudo apt-get install -y git nginx certbot python3-certbot-nginx curl postgresql-client

# Add user to docker group if not already in it
sudo usermod -aG docker ubuntu

# Create project directory
print_status "Setting up project directory..."
mkdir -p "$(dirname "$DEPLOY_PATH")"

# Clone or update repository
if [ -d "$DEPLOY_PATH" ]; then
    print_status "Updating existing repository..."
    cd "$DEPLOY_PATH"
    git fetch origin
    git reset --hard origin/main
    git clean -fd
    print_status "Repository updated to latest main branch"
else
    print_status "Cloning repository..."
    git clone "$REPO_URL" "$DEPLOY_PATH"
    cd "$DEPLOY_PATH"
    print_status "Repository cloned successfully"
fi

# Create production .env file
print_status "Creating production environment file..."
cat > .env << 'ENVEOF'
PG_PASSWORD=secureprodpassword123
PG_PORT=5432
PG_USER=blog
PG_DB=blog
PG_HOST=127.0.0.1
APP_DISABLE_SIGNUP=true
APP_PORT=22222
API_TOKEN=productionSecretToken456
ENVEOF

# Build the application
print_status "Building Go application..."
GO_VERSION="1.25.0"
# Ensure /usr/local/go/bin is on PATH for this session
export PATH=/usr/local/go/bin:$PATH
if ! command -v go &> /dev/null || [ "$(go version 2>/dev/null | awk '{print $3}')" != "go${GO_VERSION}" ]; then
    print_status "Installing Go ${GO_VERSION} (only if not present)..."
    # Detect architecture
    ARCH=$(uname -m)
    if [ "$ARCH" = "aarch64" ]; then
        GO_ARCH="arm64"
    elif [ "$ARCH" = "x86_64" ]; then
        GO_ARCH="amd64"
    else
        print_error "Unsupported architecture: $ARCH"
        exit 1
    fi
    TAR="/tmp/go${GO_VERSION}.linux-${GO_ARCH}.tar.gz"
    if [ ! -f "$TAR" ]; then
        wget -O "$TAR" "https://go.dev/dl/go${GO_VERSION}.linux-${GO_ARCH}.tar.gz"
    else
        print_status "Using cached Go archive: $TAR"
    fi
    sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf "$TAR"
    # Persist PATH for future logins if not already
    if ! grep -q "/usr/local/go/bin" ~/.bashrc 2>/dev/null; then
        echo 'export PATH=/usr/local/go/bin:$PATH' >> ~/.bashrc
    fi
    export PATH=/usr/local/go/bin:$PATH
else
    print_status "Go $(go version | awk '{print $3}') already installed - skipping download"
fi

mkdir -p tmp
go build -o tmp/blog

# Start PostgreSQL database with Docker
print_status "Starting PostgreSQL database..."
docker stop blog-postgres || true
docker rm blog-postgres || true

docker run -d \
    --name blog-postgres \
    --restart unless-stopped \
    -e POSTGRES_PASSWORD=secureprodpassword123 \
    -e POSTGRES_USER=blog \
    -e POSTGRES_DB=blog \
    -p 5432:5432 \
    -v blog-postgres-data:/var/lib/postgresql/data \
    postgres:15

# Wait for database to be ready
print_status "Waiting for database to be ready..."
sleep 10
for i in {1..30}; do
    if docker exec blog-postgres pg_isready -U blog; then
        break
    fi
    sleep 2
done

# Run database migrations if migrations directory exists
if [ -d "migrations" ]; then
    print_status "Running database migrations..."
    # Install golang-migrate if not present
    if ! command -v migrate &> /dev/null; then
        # Detect architecture for migrate binary
        ARCH=$(uname -m)
        if [ "$ARCH" = "aarch64" ]; then
            MIGRATE_ARCH="arm64"
        elif [ "$ARCH" = "x86_64" ]; then
            MIGRATE_ARCH="amd64"
        else
            print_error "Unsupported architecture for migrate: $ARCH"
            exit 1
        fi
        
        print_status "Installing golang-migrate for $MIGRATE_ARCH..."
        curl -L https://github.com/golang-migrate/migrate/releases/download/v4.16.2/migrate.linux-${MIGRATE_ARCH}.tar.gz | tar xvz
        sudo mv migrate /usr/local/bin/
        sudo chmod +x /usr/local/bin/migrate
    fi
    
    print_status "Executing database migrations..."
    migrate -source file://migrations -database "postgresql://blog:secureprodpassword123@localhost:5432/blog?sslmode=disable" up
    
    if [ $? -eq 0 ]; then
        print_status "Database migrations completed successfully"
        
        # Insert default roles
        print_status "Seeding default roles..."
        docker exec blog-postgres psql -U blog -d blog -c "
        INSERT INTO roles (role_name) VALUES 
        ('Commenter'),
        ('Administrator'), 
        ('Editor'),
        ('Viewer')
        ON CONFLICT DO NOTHING;" || print_warning "Role seeding failed but continuing..."
        
    else
        print_error "Database migrations failed"
        exit 1
    fi
else
    print_warning "No migrations directory found, skipping migrations"
fi

# Stop existing blog service
print_status "Stopping existing blog service..."
sudo systemctl stop blog || true

# Create systemd service file
print_status "Creating systemd service..."
sudo tee /etc/systemd/system/blog.service > /dev/null << 'SERVICEEOF'
[Unit]
Description=Blog Application
After=network.target docker.service
Wants=docker.service

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/projects/blog
Environment=PATH=/usr/local/go/bin:/usr/bin:/bin
EnvironmentFile=/home/ubuntu/projects/blog/.env
ExecStart=/home/ubuntu/projects/blog/tmp/blog --listen-addr :22222
Restart=always
RestartSec=10
KillMode=mixed
TimeoutStopSec=5

[Install]
WantedBy=multi-user.target
SERVICEEOF

# Reload systemd and start service
sudo systemctl daemon-reload
sudo systemctl enable blog
sudo systemctl start blog

# Setup nginx reverse proxy
print_status "Configuring nginx..."
sudo tee /etc/nginx/sites-available/blog > /dev/null << 'NGINXEOF'
server {
    listen 80;
    server_name anshumanbiswas.com www.anshumanbiswas.com;

    client_max_body_size 2M;

    location / {
        proxy_pass http://localhost:22222;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
NGINXEOF

# Enable site
sudo ln -sf /etc/nginx/sites-available/blog /etc/nginx/sites-enabled/
sudo rm -f /etc/nginx/sites-enabled/default
sudo nginx -t && sudo systemctl reload nginx

# Setup SSL with Let's Encrypt
print_status "Setting up SSL certificate with Let's Encrypt..."
sudo certbot --nginx -d anshumanbiswas.com -d www.anshumanbiswas.com --non-interactive --agree-tos --email ubuntu@anshumanbiswas.com || {
    print_warning "SSL certificate setup failed, but deployment continues..."
}

# Setup automatic certificate renewal
(sudo crontab -l 2>/dev/null; echo "0 12 * * * /usr/bin/certbot renew --quiet") | sudo crontab -

print_status "Deployment completed successfully!"
print_status "Blog should be accessible at https://$DOMAIN"

# Show service status
systemctl status blog --no-pager || true
sudo nginx -t || true
EOF
    
    # Execute remote deployment
    print_status "Executing deployment on remote server..."
    ssh "$SERVER" "/tmp/deploy_blog.sh" || {
        print_error "Remote deployment failed"
        return 1
    }
    
    # Verify deployment
    print_status "Verifying deployment..."
    sleep 5
    
    if curl -f -s "https://anshumanbiswas.com" >/dev/null 2>&1; then
        print_success "✅ Deployment successful! Blog is accessible at https://anshumanbiswas.com"
    elif curl -f -s "http://anshumanbiswas.com" >/dev/null 2>&1; then
        print_warning "⚠️  Blog is accessible at http://anshumanbiswas.com but SSL might need time to propagate"
    else
        print_error "❌ Deployment verification failed - site not responding"
        return 1
    fi
    
    # Cleanup
    ssh "$SERVER" "rm -f /tmp/deploy_blog.sh"
    print_success "Deployment process completed!"
}

# Main command handler
case ${1:-help} in
    start)
        print_header "Starting All Services"
        start_db "$2"
        start_blog "$2"
        echo ""
        show_status
        ;;
    stop)
        print_header "Stopping All Services"
        stop_blog
        stop_db
        ;;
    restart)
        print_header "Restarting All Services"
        stop_blog
        stop_db
        sleep 2
        start_db "$2"
        start_blog "$2"
        echo ""
        show_status
        ;;
    restart-blog)
        restart_blog
        ;;
    status)
        show_status
        ;;
    start-blog)
        start_blog "$2"
        ;;
    start-db)
        start_db "$2"
        ;;
    stop-blog)
        stop_blog
        ;;
    stop-db)
        stop_db
        ;;
    dev)
        start_db "$2"
        start_dev "$2"
        echo ""
        show_status
        ;;
    build)
        build_app
        ;;
    test-go)
        print_header "Running Go unit tests"
        load_env
        go test -v ./tests/go
        ;;
    test-playwright)
        print_header "Running Playwright tests"
        load_env
        node tests/playwright/test_admin_nav_playwright.js
        ;;
    test-all)
        print_header "Running All Tests"
        load_env
        go test -v ./tests/go || exit 1
        echo ""
        node tests/playwright/test_admin_nav_playwright.js || exit 1
        print_success "All tests passed"
        ;;
    docker-build)
        docker_build
        ;;
    docker-run)
        docker_run
        ;;
    logs)
        show_logs "$2" "$3"
        ;;
    tail)
        tail_logs "$2" "$3"
        ;;
    db)
        if [ -n "$2" ]; then
            execute_db_query "$2"
        else
            show_posts
        fi
        ;;
    remote-db)
        shift
        if [ $# -gt 0 ]; then
            execute_remote_db_query "$*"
        else
            print_error "Usage: $0 remote-db \"SQL_QUERY\""
            exit 1
        fi
        ;;
    remote-logs)
        view_remote_logs "$2"
        ;;
    db-migrate)
        run_migrations
        ;;
    db-reset)
        reset_database
        ;;
    db-seed)
        seed_database
        ;;
    db-users)
        show_users
        ;;
    db-posts)
        show_posts
        ;;
    db-roles)
        show_roles
        ;;
    db-categories)
        show_categories
        ;;
    add-user)
        add_user "$2" "$3" "$4" "$5"
        ;;
    add-post)
        add_post "$2" "$3" "$4" "$5" "$6"
        ;;
    add-post-from-file)
        add_post_from_file "$2" "$3" "$4" "$5"
        ;;
    upload-multiple-images)
        shift
        upload_multiple_images "$@"
        ;;
    add-category)
        add_category "$2"
        ;;
    assign-categories)
        assign_categories "$2" "$3"
        ;;
    upload-image)
        upload_image "$2" "$3"
        ;;
    toggle-signup)
        toggle_signup
        ;;
    api-test)
        test_api
        ;;
    demo-post)
        shift
        create_demo_post "$@"
        ;;
    deploy)
        shift
        deploy_to_production "$*"
        ;;
    health)
        check_health
        ;;
    clean)
        clean_files
        ;;
    ports)
        show_ports
        ;;
    env)
        show_env
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        print_error "Unknown command: $1"
        echo ""
        show_help
        exit 1
        ;;
esac
